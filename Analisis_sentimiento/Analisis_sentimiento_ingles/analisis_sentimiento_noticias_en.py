# -*- coding: utf-8 -*-
"""analisis_sentimiento_noticias_en.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A3TFceyDDy2ZXK2io3fSKuxXHVaQieuV

# Pruebas de modelo para analizar sentimiento de noticias en inglés

### Paso 1: Configuración del Entorno y Librerías

Se instalan las bibliotecas necesarias y se importan los módulos clave. `transformers` es el módulo principal para trabajar con modelos de Hugging Face. `pandas` se utiliza para la manipulación de datos, `torch` para el cómputo con la GPU, y `re` e `io` para manejar la lectura y limpieza del archivo de manera eficiente.
"""

!pip install transformers pandas torch

import pandas as pd
import re
import io
import torch
import numpy as np
from transformers import AutoTokenizer, AutoModelForSequenceClassification
from google.colab import drive

# Montar Google Drive
drive.mount('/content/drive')

"""### Paso 2: Carga y Preparación de los Datos

En este bloque, montamos Google Drive para acceder a nuestros archivos. El código se centra en una técnica de procesamiento en memoria (`io.StringIO`) para leer y limpiar el archivo CSV sin tener que crear y guardar un nuevo archivo temporal. Esto es crucial para manejar grandes volúmenes de datos de forma rápida y eficiente en un entorno como Colab.
"""

# Definir las rutas de los archivos
# Ruta del archivo original en tu Google Drive (solo necesitamos este)
original_file_path = '/content/drive/MyDrive/UCM/TFM/NOTICIAS_POR_ANALIZAR.csv'

# Leer y limpiar el contenido del archivo en memoria (sin crear un archivo limpio)
print(f"Leyendo y limpiando el contenido de '{original_file_path}' en memoria...")
cleaned_lines = []
try:
    with open(original_file_path, 'r', encoding='utf-8') as infile:
        header = next(infile)
        cleaned_lines.append(header) # Guardar el encabezado

        for line in infile:
            if line.strip().startswith('"') and ',' in line[1:]:
                # Reemplazar el formato incorrecto en memoria
                line_fixed = re.sub(r'^"(\d+),""', r'\1,"', line.strip())
                line_fixed = re.sub(r'""', r'"', line_fixed)
                cleaned_lines.append(line_fixed + '\n')
            else:
                cleaned_lines.append(line)

    # Unir las líneas limpias en una sola cadena para que Pandas pueda leerlo
    cleaned_csv_string = "".join(cleaned_lines)

    # Usar `io.StringIO` para tratar la cadena como un archivo en memoria
    # Esto evita tener que guardar un archivo limpio en el disco.
    cleaned_csv_file = io.StringIO(cleaned_csv_string)

    # Leer el archivo virtual en un DataFrame de Pandas
    df = pd.read_csv(cleaned_csv_file)
    print(f"DataFrame cargado y limpio en memoria con {len(df)} registros.")
    print(df.head())

except FileNotFoundError:
    print(f"Error: El archivo original '{original_file_path}' no se encontró. Verifica la ruta.")
    df = None

df.info()

"""### Paso 3: Carga del Modelo de Análisis de Sentimiento

En esta sección, cargamos el modelo de IA pre-entrenado (`distilroberta`) y su tokenizador. La selección de este modelo se basa en su especialización en el análisis de sentimiento de noticias financieras. También configuramos el entorno para que use la GPU (`cuda`) si está disponible, lo cual acelera drásticamente las predicciones.

### Paso 4: Definición de la Función de Predicción

Se crea una función `get_sentiment` que encapsula toda la lógica del análisis. Toma un texto de entrada, lo procesa para el modelo (tokenización y conversión a tensores), realiza la predicción de sentimiento y devuelve la etiqueta de sentimiento (Positivo, Negativo, Neutral) y sus probabilidades.
"""

# Cargar el modelo y el tokenizer
if df is not None:
    model_name = "mrm8488/distilroberta-finetuned-financial-news-sentiment-analysis"
    tokenizer = AutoTokenizer.from_pretrained(model_name)
    model = AutoModelForSequenceClassification.from_pretrained(model_name)
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)
    model.eval()
    print("\nModelo y tokenizer cargados correctamente.")

    # Definir la función de predicción
    def get_sentiment(text):
        if not isinstance(text, str) or pd.isna(text):
            return 'N/A', np.nan, np.nan, np.nan

        inputs = tokenizer(text, return_tensors="pt", truncation=True, padding=True, max_length=512)
        inputs = {key: val.to(device) for key, val in inputs.items()}

        with torch.no_grad():
            outputs = model(**inputs)

        probabilities = torch.softmax(outputs.logits, dim=1)[0].cpu().numpy()

        label_mapping = {
            0: 'Negativo',
            1: 'Neutral',
            2: 'Positivo'
        }

        predicted_class_id = np.argmax(probabilities)
        sentiment = label_mapping[predicted_class_id]

        prob_negative = probabilities[0]
        prob_neutral = probabilities[1]
        prob_positive = probabilities[2]

        return sentiment, prob_positive, prob_negative, prob_neutral

    # Aplicar el análisis solo a los titulares en inglés
    print("\nIniciando el análisis de sentimiento para titulares en inglés ('en')...")

    # Obtener los índices de los registros en inglés
    english_indices = df[df['IDIOMA'] == 'en'].index

    # Iterar solo sobre los registros en inglés
    for index in english_indices:
        titular = df.loc[index, 'TITULAR']
        sentiment, prob_pos, prob_neg, prob_neut = get_sentiment(titular)

        # Llenar las columnas de sentimiento solo para los registros en inglés
        df.loc[index, 'SENTIMIENTO_RESULTADO'] = sentiment
        df.loc[index, 'PROBABILIDAD_POSITIVO'] = prob_pos
        df.loc[index, 'PROBABILIDAD_NEGATIVA'] = prob_neg
        df.loc[index, 'PROBABILIDAD_NEUTRAL'] = prob_neut

    print("Análisis de sentimiento completado.")
    print("\nDataFrame con los resultados finales:")
    print(df[['ID', 'FECHA', 'TITULAR', 'IDIOMA', 'SENTIMIENTO_RESULTADO', 'PROBABILIDAD_POSITIVO']].head())

"""Se aplican las predicciones del modelo a los datos del DataFrame. El código filtra los registros para analizar solo aquellos con el idioma 'en' (inglés). Luego, itera sobre cada titular, llama a la función de predicción y llena las columnas de sentimiento y probabilidad en el DataFrame."""

print(df[['FECHA', 'TITULAR', 'sentimiento_resultado', 'probabilidad_positivo', 'probabilidad_negativa', 'probabilidad_neutral']].head())

# Guardar el resultado final en un nuevo archivo CSV en Drive
    output_file_path = '/content/drive/MyDrive/UCM/TFM/analisis_en.csv'
    df.to_csv(output_file_path, index=False)
    print(f"\nResultados guardados en '{output_file_path}'.")

df.info()

"""#TFM GRUPO 4"""